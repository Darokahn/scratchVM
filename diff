diff --git a/source/definitions.c b/source/definitions.c
index c28315a..4824832 100644
@@ -4,6 +4,6 @@
diff --git a/source/externalDefinitions.c b/source/externalDefinitions.c
index 56e658b..9ef6705 100644
--- a/source/externalDefinitions.c
+++ b/source/externalDefinitions.c
@@ -61,14 +61,27 @@ void* mallocDMA(size_t size) {
 void drawSprites(struct SCRATCH_sprite** sprites, int spriteCount, const pixel** imageTable) {
     for (int i = 0; i < spriteCount; i++) {
         struct SCRATCH_sprite* sprite = sprites[i];
-        const pixel* image = getImage(imageTable, i, sprite->base.costumeIndex);
+        struct image* image = getImage(imageTable, i, sprite->base.costumeIndex);
         int imageResolution;
-        if (i == 0) imageResolution = 128;
-        else imageResolution = 32;
-        int baseX = sprite->base.x.halves.high * WIDTHRATIO;
-        int baseY = sprite->base.y.halves.high * HEIGHTRATIO;
-        int width = ((float)sprite->base.widthRatio / 255) * LCDWIDTH;
-        int height = ((float)sprite->base.heightRatio / 255) * LCDHEIGHT;
+        int baseX;
+        int baseY;
+        int width;
+        int height;
+        if (i == 0) {
+            imageResolution = 128;
+            baseX = 0;
+            baseY = 0;
+            width = LCDWIDTH;
+            height = LCDHEIGHT;
+        }
+        else {
+            imageResolution = 32;
+            baseX = sprite->base.x.halves.high + (SCRATCHWIDTH / 2) * WIDTHRATIO;
+            baseY = -sprite->base.y.halves.high + (SCRATCHWIDTH / 2) * HEIGHTRATIO;
+            width = ((float)image->widthRatio / 255) * LCDWIDTH;
+            height = ((float)image->heightRatio/ 255) * LCDHEIGHT;
+        }
+        // convert from inner scratch-centric coordinates to real screen coordinates
         float xStride = ((float)imageResolution) / width;
         float yStride = ((float)imageResolution) / height;
         for (int y = 0; y < height; y++) {
@@ -76,7 +89,7 @@ void drawSprites(struct SCRATCH_sprite** sprites, int spriteCount, const pixel**
                 if (y + baseY >= LCDHEIGHT || x + baseX >= LCDWIDTH || y + baseY < 0 || x + baseX < 0) continue;
                 int row = (y * yStride);
                 int index = ((row * imageResolution) + (x * xStride));
-                pixel color = image[index];
+                pixel color = image->pixels[index];
 
                 // transparent pixels reveal white if they are on the background; do nothing if they are on a sprite.
                 if (color == 0) {
@@ -97,12 +110,12 @@ void debugImage(pixel *img, int width, int height) {
             pixel pixel = img[y * width + x];
 
             uint8_t r = (pixel >> 11) & 31;
-            uint8_t g = (pixel >> 5) & 64;
+            uint8_t g = (pixel >> 5) & 63;
             uint8_t b = pixel & 31;
 
-            uint8_t R = (r * 255) / 31;
-            uint8_t G = (g * 255) / 63;
-            uint8_t B = (b * 255) / 31;
+            uint8_t R = (r << 3) | (r >> 2); // replicate high bits to low
+            uint8_t G = (g << 2) | (g >> 4);
+            uint8_t B = (b << 3) | (b >> 2);
 
             pixelPointer += sprintf(pixelPointer, "\x1b[48;2;%u;%u;%um  ", R, G, B);
         }
diff --git a/source/generateDefinitions.c b/source/generateDefinitions.c
index bc6352f..6db1891 100644
--- a/source/generateDefinitions.c
+++ b/source/generateDefinitions.c
@@ -14,6 +14,12 @@ enum SCRATCH_opcode* code;
 
 typedef uint16_t pixel;
 
+struct image {
+    uint8_t widthRatio;
+    uint8_t heightRatio;
+    pixel pixels[];
+};
+
 #define SIZE 128
 
 #define SIZE128 128
@@ -148,8 +154,6 @@ void mockProgram() {
         .visible = true,
         .layer = 0,
         .size = 128,
-        .widthRatio = 255,
-        .heightRatio = 255,
         .rotationStyle = 0,
         .costumeIndex = 0,
         .costumeMax = 1,
@@ -164,8 +168,6 @@ void mockProgram() {
         .visible = true,
         .layer = 0,
         .size = 128,
-        .widthRatio = 64,
-        .heightRatio = 64,
         .rotationStyle = 0,
         .costumeIndex = 0,
         .costumeMax = 1,
@@ -180,32 +182,58 @@ void mockProgram() {
         .entryPoint = 0
     };
 
+    struct image backgroundHeader = {
+        255, 255
+    };
+    struct image spriteHeader = {
+        50, 50
+    };
+
     generatePatterns();
     drawLetters();
     uint8_t* data = (uint8_t*) programData;
+    // code
     memcpy(data, codeTemplate, sizeof codeTemplate);
     data += sizeof codeTemplate;
     data = ALIGN8(data);
+
+    // background image
+    memcpy(data, &backgroundHeader, sizeof backgroundHeader);
+    data += sizeof backgroundHeader;
     memcpy(data, pattern128, sizeof pattern128);
     data += sizeof pattern128; // no need for alignment in the image buffer
+
+
+    // sprite image
+    memcpy(data, &spriteHeader, sizeof spriteHeader);
+    data += sizeof spriteHeader;
     memcpy(data, pattern32, sizeof pattern32);
     data += sizeof pattern32;
     data = ALIGN8(data);
+
+    // stage
     memcpy(data, &stageTemplate, sizeof stageTemplate);
     data += sizeof stageTemplate;
     data = ALIGN8(data);
+
+    // thread
     memcpy(data, &threadTemplate1, sizeof threadTemplate1);
     data += sizeof threadTemplate1;
     data = ALIGN8(data);
+
+    // sprite
     memcpy(data, &spriteTemplate, sizeof spriteTemplate);
     data += sizeof spriteTemplate;
     data = ALIGN8(data);
+
+    // thread
     memcpy(data, &threadTemplate2, sizeof threadTemplate2);
     data += sizeof threadTemplate2;
     data = ALIGN8(data);
+
     header.spriteCount = 2;
     header.codeLength = (int)(uintptr_t)ALIGN8(sizeof codeTemplate);
-    header.imageLength = sizeof pattern128 + sizeof pattern32;
+    header.imageLength = sizeof pattern128 + sizeof backgroundHeader + sizeof pattern32 + sizeof spriteHeader;
 }
 
 void writeMock() {
diff --git a/source/graphics.h b/source/graphics.h
index 26c578f..4125b0e 100644
--- a/source/graphics.h
+++ b/source/graphics.h
@@ -3,8 +3,8 @@
 
 #include "scratch.h"
 
-#define LCDWIDTH 240
-#define LCDHEIGHT 180
+#define LCDWIDTH 320
+#define LCDHEIGHT 240
 
 #define SCRATCHWIDTH 480
 #define SCRATCHHEIGHT 360
@@ -13,4 +13,10 @@
 #define HEIGHTRATIO (((float) LCDHEIGHT) / SCRATCHHEIGHT)
 
 typedef uint16_t pixel;
+
+struct image {
+    uint8_t widthRatio;
+    uint8_t heightRatio;
+    pixel pixels[];
+};
 #endif
diff --git a/source/main.c b/source/main.c
index 4d8a7b1..fc73378 100644
--- a/source/main.c
+++ b/source/main.c
@@ -16,7 +16,5 @@ int main() {
         SCRATCH_visitAllThreads(sprites, header.spriteCount);
         drawSprites(sprites, 2, imageTable);
         updateGraphics();
-        puts("=============");
-        debugImage(getImage(imageTable, 0, 1), 128, 128);
     }
 }
diff --git a/source/programData.c b/source/programData.c
index c2a94a6..ddfa268 100644
--- a/source/programData.c
+++ b/source/programData.c
@@ -3,22 +3,23 @@
 #include "programData.h"
 #include "scratch.h"
 
-const pixel* getImage(const pixel* imageTable[IMAGEMAX], int spriteIndex, int costumeIndex) {
+struct image* getImage(const pixel* imageTable[IMAGEMAX], int spriteIndex, int costumeIndex) {
     int imageResolution;
     // The first sprite is implicitly the stage
     if (spriteIndex == 0) imageResolution = STAGERESOLUTION;
     else imageResolution = SPRITERESOLUTION;
+    int imageSize = imageResolution * imageResolution * sizeof (pixel) + sizeof(struct image);
 
-    const pixel* base = imageTable[spriteIndex];
-    base += costumeIndex * (imageResolution * imageResolution);
-    return base;
+    uint8_t* base = (uint8_t*) imageTable[spriteIndex];
+    base += costumeIndex * imageSize;
+    return (struct image*) base;
 }
 
 void initData(const struct SCRATCH_header header, const uint8_t* buffer, struct SCRATCH_sprite* sprites[SPRITEMAX], const pixel* images[IMAGEMAX]) {
     code = (enum SCRATCH_opcode*) buffer;
     buffer += header.codeLength;
     buffer = ALIGN8(buffer);
-    const pixel* imageBase = (const pixel*) buffer;
+    const uint8_t* imageBase = (const uint8_t*) buffer;
     int imageIndex = 0;
     buffer += header.imageLength;
     buffer = ALIGN8(buffer);
@@ -35,11 +36,11 @@ void initData(const struct SCRATCH_header header, const uint8_t* buffer, struct
             buffer = ALIGN8(buffer);
         }
         int imageSize;
-        if (i == 0) imageSize = STAGERESOLUTION * STAGERESOLUTION;
-        else imageSize = SPRITERESOLUTION * SPRITERESOLUTION;
+        if (i == 0) imageSize = STAGERESOLUTION * STAGERESOLUTION * sizeof(pixel) + sizeof (struct image);
+        else imageSize = SPRITERESOLUTION * SPRITERESOLUTION * sizeof(pixel) + sizeof (struct image);
+        images[imageIndex] = (pixel*) imageBase;
+        imageIndex++;
         for (int j = 0; j < h.costumeMax; j++) {
-            images[imageIndex] = imageBase;
-            imageIndex++;
             imageBase += imageSize;
         }
     }
diff --git a/source/programData.h b/source/programData.h
index 54cc7bb..413969d 100644
--- a/source/programData.h
+++ b/source/programData.h
@@ -31,7 +31,7 @@ extern const struct SCRATCH_header header;
 extern const uint8_t programData[];
 extern enum SCRATCH_opcode* code;
 
-const pixel* getImage(const pixel* images[IMAGEMAX], int spriteIndex, int costumeIndex);
+struct image* getImage(const pixel* images[IMAGEMAX], int spriteIndex, int costumeIndex);
 
 void initData(const struct SCRATCH_header header, const uint8_t* buffer, struct SCRATCH_sprite* sprites[SPRITEMAX], const pixel* images[IMAGEMAX]);
 #endif
diff --git a/source/scratch.h b/source/scratch.h
index 12b6704..dd88541 100644
--- a/source/scratch.h
+++ b/source/scratch.h
@@ -207,8 +207,6 @@ struct SCRATCH_spriteHeader {
     bool visible;
     int8_t layer;
     uint16_t size; // number representing percent of original size
-    uint8_t widthRatio; // ratio of sprite width to screen width when unscaled, as a map from (0 -> 1) to (0 -> 255).
-    uint8_t heightRatio;
     bool rotationStyle;
     uint8_t costumeIndex;
     uint8_t costumeMax;
diff --git a/source/test.c b/source/test.c
index b0ac0ae..ba239c0 100644
--- a/source/test.c
+++ b/source/test.c
@@ -9,8 +9,6 @@ int main(void) {
     printf("visible       = %zu\n", offsetof(struct SCRATCH_spriteHeader, visible));
     printf("layer         = %zu\n", offsetof(struct SCRATCH_spriteHeader, layer));
     printf("size          = %zu\n", offsetof(struct SCRATCH_spriteHeader, size));
-    printf("widthRatio    = %zu\n", offsetof(struct SCRATCH_spriteHeader, widthRatio));
-    printf("heightRatio   = %zu\n", offsetof(struct SCRATCH_spriteHeader, heightRatio));
     printf("rotationStyle = %zu\n", offsetof(struct SCRATCH_spriteHeader, rotationStyle));
     printf("costumeIndex  = %zu\n", offsetof(struct SCRATCH_spriteHeader, costumeIndex));
     printf("costumeMax    = %zu\n", offsetof(struct SCRATCH_spriteHeader, costumeMax));
diff --git a/todo.md b/todo.md
new file mode 100644
index 0000000..774f22a
--- /dev/null
+++ b/todo.md
@@ -0,0 +1,10 @@
+# TODO
+- Code Compilation
+- Events
+- Speech
+- Many Blocks
+
+# DOING
+
+# DONE
+- Sprite Adjusting
diff --git a/webConverter/script.mjs b/webConverter/script.mjs
index 2ed5259..4c5fc44 100644
--- a/webConverter/script.mjs
+++ b/webConverter/script.mjs
@@ -1,29 +1,30 @@
 import { unzipSync } from "https://unpkg.com/fflate/esm/browser.js";
 import mime from 'https://cdn.skypack.dev/mime'; 
 
+const SCRATCHWIDTH = 480;
+const SCRATCHHEIGHT = 360;
+
 const files = {};
 
 const offsets = {
     sprite: {
-        x: { offset: 0, size: 4 },
-        y: { offset: 4, size: 4 },
-        rotation: { offset: 8, size: 2 },
+        x: { offset: 0, size: 4 }, // scaledInt32 (high half is whole number, low half is fractional number)
+        y: { offset: 4, size: 4 }, // scaledInt32
+        rotation: { offset: 8, size: 2 }, // scaled rotation (0 -> 360 maps to 0 -> 655636)
         visible: { offset: 10, size: 1 },
         layer: { offset: 11, size: 1 },
         size: { offset: 12, size: 2 },
-        widthRatio: { offset: 14, size: 1 },
-        heightRatio: { offset: 15, size: 1 },
-        rotationStyle: { offset: 16, size: 1 },
-        costumeIndex: { offset: 17, size: 1 },
-        costumeMax: { offset: 18, size: 1 },
-        threadCount: { offset: 19, size: 1 },
-        variableCount: { offset: 20, size: 1 },
-        sizeof: 24
+        rotationStyle: { offset: 14, size: 1 }, // bool
+        costumeIndex: { offset: 15, size: 1 },
+        costumeMax: { offset: 16, size: 1 },
+        threadCount: { offset: 17, size: 1 },
+        variableCount: { offset: 18, size: 1 },
+        sizeof: 20
     },
     thread: {
-        eventCondition: { offset: 0, size: 2 },
+        eventCondition: { offset: 0, size: 2 }, // enum
         entryPoint: { offset: 2, size: 2 },
-        startEvent: { offset: 4, size: 2 },
+        startEvent: { offset: 4, size: 2 }, // enum
         sizeof: 6
     }
 };
@@ -46,8 +47,6 @@ function spriteTemplate() {
         visible: true,
         layer: 0,
         size: 128,
-        widthRatio: 20,
-        heightRatio: 20,
         rotationStyle: 0,
         costumeIndex: 0,
         costumeMax: 0,
@@ -68,6 +67,22 @@ function detailsTemplate() {
     };
 }
 
+function toScaledInt32(x) {
+    // Clamp and convert to 16-bit signed
+    x = (x << 16) >> 16;
+    return x << 16;
+}
+
+function degreesToScaled16(degrees) {
+    // Normalize degrees to [0, 360)
+    degrees = ((degrees % 360) + 360) % 360;
+
+    // Scale to 0â€“65536 range (wraps naturally in 16-bit)
+    let scaled = Math.round((degrees / 360) * 65536) & 0xFFFF;
+
+    return scaled;
+}
+
 // get the sb3 file from the operation layer
 function getFsEntry(name) {
     return files[name];
@@ -128,13 +143,19 @@ function getDetails(project) {
 // adjust the sprite's parameters to match the quirks of my C representation
 
 function adjustSprite(sprite, isStage) {
-    for (let i = 0; i < sprite.threadCount; i++) {
+    if (isStage) {
+        sprite.threads = [];
         sprite.threads.push(threadTemplate());
+        sprite.threads[0].entryPoint = 18;
     }
-    if (isStage) {
-        console.log(sprite);
+    else {
+        for (let i = 0; i < sprite.threadCount; i++) {
+            sprite.threads.push(threadTemplate());
+        }
     }
-
+    sprite.x = toScaledInt32(sprite.x);
+    sprite.y = toScaledInt32(sprite.y);
+    sprite.rotation = degreesToScaled16(sprite.rotation);
 }
 
 // copy a sprite into the array's memory
@@ -154,12 +175,12 @@ function copyStruct(buffer, offset, struct, name) {
         if (field == "sizeof") continue;
         let offsetData = layout[field];
         let totalOffset = offset + offsetData.offset;
-        view[ "set" + sizes[offsetData.size]](totalOffset, struct[field], true);
-        let value = view["get" + sizes[offsetData.size]](totalOffset, true);
+        let setSize = "set" + sizes[offsetData.size];
+        view[setSize](totalOffset, struct[field], true);
     }
 }
 
-let PROJECTMAX = 4096 * 20;
+let PROJECTMAX = 4096 * 100;
 
 async function convertScratchProject() {
     let header = {
@@ -181,30 +202,37 @@ async function convertScratchProject() {
     index = (index + 7) & ~7;
     header.codeLength = index;
     for (let image of details.stageImages) {
-        let array = await getScaledImage(file, image, true);
-        let canvas = document.createElement('canvas');
-        drawScaledImageToCanvas(canvas, array);
+        let {scaledImage, width, height} = await getScaledImageFromFile(file, image, true);
+        let array = scaledImage;
+        array = RGB888to565(array);
+        let canvas = drawRGB565ToCanvas(array, 128, 128);
         document.body.appendChild(canvas);
-        buffer.set(array, index);
+        buffer.set(new Uint8Array([255, 255]), index);
+        index += 2;
+        buffer.set(new Uint8Array(array.buffer), index);
         index += array.byteLength;
     }
     for (let image of details.spriteImages) {
-        let array = await getScaledImage(file, image, false);
-        let canvas = document.createElement('canvas');
-        drawScaledImageToCanvas(canvas, array);
+        let {scaledImage, width, height} = await getScaledImageFromFile(file, image, false);
+        let array = scaledImage;
+        let widthRatio = 255 * width /SCRATCHWIDTH; // TODO width is to SCRATCHWIDTH as x is to 255? widthRatio must actually be x, because it is scaled from 0 to 255.
+        let heightRatio = 255 * height /SCRATCHHEIGHT;
+        array = RGB888to565(array);
+        let canvas = drawRGB565ToCanvas(array, 32, 32);
         document.body.appendChild(canvas);
-        buffer.set(array, index);
+        buffer.set(new Uint8Array([widthRatio, heightRatio]), index);
+        index += 2;
+        buffer.set(new Uint8Array(array.buffer), index);
         index += array.byteLength;
     }
     index = (index + 7) & ~7;
     header.imageLength = index - header.codeLength;
     for (let sprite of details.sprites) {
-        console.log("doing sprite");
+        console.log(sprite);
         copyStruct(buffer.buffer, index, sprite, "sprite");
         index += offsets.sprite.sizeof;
         index = (index + 7) & ~7;
         for (let thread of sprite.threads) {
-            console.log("doing thread");
             copyStruct(buffer.buffer, index, thread, "thread");
             index += offsets.thread.sizeof;
             index = (index + 7) & ~7;
@@ -265,50 +293,125 @@ async function drawAndGetPixels(uint8arr, mimeType) {
     }
 }
 
-async function getScaledImage(directory, filename, isStage) {
-    let resolution = isStage * 128 + !isStage * 32;
-    let file = directory[filename];
-    let type = mime.getType(filename);
-    let {pixels, width, height} = await drawAndGetPixels(file, type);
-    let scaledImage = new Uint16Array(resolution * resolution);
-    let xStride = (width / resolution);
-    let yStride = (height / resolution);
-    for (let y = 0; y < resolution * 3; y += 3) {
-        for (let x = 0; x < resolution * 3; x += 3) {
-            let index = Math.trunc(y * resolution * yStride) + Math.trunc(x * xStride);
-            let red = pixels[index];
-            let green = pixels[index + 1];
-            let blue = pixels[index + 2];
-            scaledImage[y / 3 * resolution + x / 3] = (red * 255/32 ) << 11 | (green  * 255/63) << 5 | (blue * 255/32);
+async function scaleImage(pixels, width, height, targetWidth, targetHeight) {
+    let scaledImage = new Uint8Array(targetWidth * targetHeight * 3);
+    let xStride = (width / targetWidth);
+    let yStride = (height / targetHeight);
+    let rowLengthSource = width;
+    let rowLengthScaled = targetWidth;
+    for (let y = 0; y < targetHeight; y++) {
+        for (let x = 0; x < targetWidth; x ++) {
+            let sourceIndex = Math.trunc(y * yStride) * rowLengthSource + Math.trunc(x * xStride);        // index into an RGBA array
+            let scaledIndex = y * rowLengthScaled + x;                               // index into an RGB array
+            sourceIndex *= 4;
+            scaledIndex *= 3;
+            scaledImage[scaledIndex] = pixels[sourceIndex];
+            scaledImage[scaledIndex+1] = pixels[sourceIndex+1];
+            scaledImage[scaledIndex+2] = pixels[sourceIndex+2];
         }
     }
     return scaledImage;
 }
 
-function drawScaledImageToCanvas(canvas, scaledImage) {
-    const ctx = canvas.getContext('2d');
-    const resolution = Math.sqrt(scaledImage.length);
-    canvas.width = resolution;
-    canvas.height = resolution;
+function drawRGB888ToCanvas(rgbArray, width, height) {
+    if (rgbArray.length !== width * height * 3) {
+        throw new Error("Array length does not match width*height*3");
+    }
 
-    const imageData = ctx.createImageData(resolution, resolution);
+    // Create a canvas
+    const canvas = document.createElement("canvas");
+    canvas.width = width;
+    canvas.height = height;
+    const ctx = canvas.getContext("2d");
+
+    // Create an ImageData object (RGBA)
+    const imageData = ctx.createImageData(width, height);
     const data = imageData.data;
 
-    for (let i = 0, j = 0; i < scaledImage.length; i++, j += 4) {
-        const color = scaledImage[i];
-        const r = ((color >> 11) & 0x1F) * 255 / 31;
-        const g = ((color >> 5) & 0x3F) * 255 / 63;
-        const b = (color & 0x1F) * 255 / 31;
+    // Convert RGB array to RGBA
+    for (let i = 0, j = 0; i < rgbArray.length; i += 3, j += 4) {
+        data[j] = rgbArray[i];       // R
+        data[j + 1] = rgbArray[i + 1]; // G
+        data[j + 2] = rgbArray[i + 2]; // B
+        data[j + 3] = 255;           // A
+    }
 
-        data[j]     = r;
-        data[j + 1] = g;
-        data[j + 2] = b;
-        data[j + 3] = 255; // opaque
+    // Put the image data on the canvas
+    ctx.putImageData(imageData, 0, 0);
+
+    return canvas;
+}
+
+function RGB888to565(uint8Array) {
+    let result = new Uint16Array(uint8Array.length / 3);
+    for (let i = 0; i < result.length; i++) {
+        let sourceIndex = i * 3;
+        let red = uint8Array[sourceIndex];
+        let green = uint8Array[sourceIndex + 1];
+        let blue = uint8Array[sourceIndex + 2];
+        let alpha = uint8Array[sourceIndex + 3];
+        red = Math.floor(red * 31 / 255);
+        green = Math.floor(green * 63 / 255);
+        blue = Math.floor(blue * 31 / 255);
+        let finalColor = red << 11 | green << 5 | blue;
+        if (finalColor == 0 && alpha != 0) {
+            finalColor = 1; // Use a slight off-black when the value is 0, 0, 0 so that 0, 0, 0 can be reserved for transparency.
+        }
+        result[i] = finalColor;
+    }
+    return result;
+}
+
+function drawRGB565ToCanvas(rgb565Array, width, height) {
+    if (rgb565Array.length !== width * height) {
+        throw new Error("Array length does not match width*height");
+    }
+
+    const canvas = document.createElement("canvas");
+    canvas.width = width;
+    canvas.height = height;
+    const ctx = canvas.getContext("2d");
+    const imageData = ctx.createImageData(width, height);
+    const data = imageData.data;
+
+    for (let i = 0; i < rgb565Array.length; i++) {
+        const value = rgb565Array[i];
+
+        // Extract R, G, B components
+        const r5 = (value >> 11) & 0x1F; // 5 bits red
+        const g6 = (value >> 5) & 0x3F;  // 6 bits green
+        const b5 = value & 0x1F;         // 5 bits blue
+
+        // Convert to 8-bit per channel
+        const r8 = (r5 << 3) | (r5 >> 2); // replicate high bits to low
+        const g8 = (g6 << 2) | (g6 >> 4);
+        const b8 = (b5 << 3) | (b5 >> 2);
+
+        const j = i * 4;
+        data[j] = r8;
+        data[j + 1] = g8;
+        data[j + 2] = b8;
+        data[j + 3] = 255; // fully opaque
     }
+
     ctx.putImageData(imageData, 0, 0);
+    return canvas;
 }
 
-function main() {
+async function getScaledImageFromFile(directory, filename, isStage) {
+    let resolution = isStage * 128 + !isStage * 32;
+    let file = directory[filename];
+    let type = mime.getType(filename);
+    let {pixels, width, height} = await drawAndGetPixels(file, type);
+    let scaledImage = await scaleImage(pixels, width, height, resolution, resolution);
+    return {scaledImage, width, height};
+}
+
+function assert(condition, phrase) {
+    if (!condition) console.log("ERROR: " + phrase);
+}
+
+async function main() {
     const dropzone = document.getElementById("dropzone");
 
     dropzone.addEventListener("dragover", e => {
@@ -324,11 +427,6 @@ function main() {
       e.preventDefault();
       dropzone.style.background = "";
         
-        console.log("origin: ", location.origin);
-        console.log("referrer: ", document.referrer);
-        console.log("Security Policy: ", document.querySelector("meta[http-equiv='Content-Security-Policy']"));
-        console.log("dataTransfer [files, items]: ", e.dataTransfer.files, e.dataTransfer.items);
-
       const file = e.dataTransfer.files[0];
       if (file && file.name.endsWith(".sb3")) {
           addZipToFs(file);
